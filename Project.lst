Microsoft (R) Macro Assembler Version 14.28.29913.0	    07/07/21 23:31:08
asm3_Q3.asm						     Page 1 - 1



				INCLUDE Irvine32.inc
			      C ; Include file for Irvine32.lib             (Irvine32.inc)
			      C 
			      C ;OPTION CASEMAP:NONE		; optional: make identifiers case-sensitive
			      C 
			      C INCLUDE SmallWin.inc		; MS-Windows prototypes, structures, and constants
			      C .NOLIST
			      C .LIST
			      C 
			      C INCLUDE VirtualKeys.inc
			      C ; VirtualKeys.inc
			      C .NOLIST
			      C .LIST
			      C 
			      C 
			      C .NOLIST
			      C .LIST
			      C 
				INCLUDE asm3_Q3_data.inc
 00000000		      C .data
 00000000 32 33 35 38 31      C num byte "235813", 0
	   33 00
 = 00000007		      C N=Lengthof num
 00000007  0000000F [	      C res byte N*2+1 dup (0)
	    00
	   ]
			      C 

				;What does the program do? This program recives a string and it's size, and checks if it is an additive sequence or not.
				;if not - it will print "false", if it is an additive sequence it will print the numbers that form the given sequence .

				;registers used: above every function is an explanation of what the function does and whar registers were used and for what.
				;in main: edx was used to print strings, and the registers esi, edx and edi were used to send parameters to the main function
				;of this prigram: "isAddSeq". 

 00000016			.data
 00000016 49 6E 70 75 74	Input BYTE "Input: s = " , 0
	   3A 20 73 20 3D
	   20 00
 00000022 4F 75 74 70 75	Output BYTE "Output: ", 0
	   74 3A 20 00
 0000002B 66 61 6C 73 65	falseOutput BYTE "false", 0
	   00

 00000000			.code
 00000000			main PROC
 00000000  E8 00000000 E	call crlf
 00000005  BA 00000016 R	mov edx, OFFSET INPUT
 0000000A  E8 00000000 E	call WriteString
 0000000F  BA 00000000 R	mov edx, OFFSET num
 00000014  E8 00000000 E	call writeString


 00000019  BE 00000000 R	mov esi, OFFSET NUM
 0000001E  BA 00000007		mov EDX, N
 00000023  BF 00000007 R	mov EDI, OFFSET res
 00000028  56			push esi
 00000029  52			push edx
 0000002A  57			push edi
 0000002B  E8 00000286		call IsAddSeq

 00000030  E8 00000000 E	 call crlf
 00000035  E8 00000000 E	 call crlf
 0000003A  BA 00000022 R	mov edx, OFFSET Output
 0000003F  E8 00000000 E	call writeString
 00000044  BA 00000007 R	mov edx, OFFSET res
 00000049  80 3A 00		cmp BYTE PTR[edx], 0
 0000004C  74 07		JZ ReturnedFalse

 0000004E  E8 00000000 E	call writeString
 00000053  EB 0A		jmp endMain 

 00000055			ReturnedFalse:
 00000055  BA 0000002B R	mov edx, OFFSET falseOutput
 0000005A  E8 00000000 E	call WriteString

 0000005F			endMain:


						exit
 0000005F  6A 00	   *	    push   +000000000h
 00000061  E8 00000000 E   *	    call   ExitProcess

 00000066					main ENDP

				;------------------------------------
				;function explained: checks if string valid
				;registers uded: parameters: esi - len, edi - adress of string. al - boolian result
				;adress is 4 bytes to is stored in a full register, len is unkown so also stored in a 4 byte register
 00000066			IsValid PROC uses ESI EDI ;boolian function, returns true/false in al
 00000066  56		   *	    push   esi
 00000067  57		   *	    push   edi
 00000068  55				push EBP
 00000069  8B EC			mov EBP, ESP;ADDED USES + 8
					;---------------
 0000006B  8B 75 14			mov esi, [ebp + 20] ;len of string
 0000006E  8B 7D 10			mov edi, [ebp + 16] ;adress of string
 00000071  83 FE 01			cmp esi, 1
 00000074  72 09			jb notGreater
 00000076  80 3F 30			cmp BYTE PTR[edi], "0"
 00000079  75 04			jnz notEquel
 0000007B  B0 00			mov al, 0
 0000007D  EB 02			jmp endOfFunction

 0000007F				notGreater:
 0000007F				notEquel:
 0000007F  B0 01			mov al, 1

 00000081				endOfFunction:
					;---------------
 00000081  8B E5			mov ESP, EBP
 00000083  5D				pop EBP
 00000084  5F		   *	    pop    edi
 00000085  5E		   *	    pop    esi
 00000086  C2 0008			ret 8 ;make sure  is 8
 00000089				IsValid ENDP

					;----------------------------------------------------------------------------------
					;function explained: this function returns the numeric value of the char recived in the string
					;registers used: parameter list: edx - position, esi - len, edi - adress of string. al holds result
					;adress are stored in a 4 byte register, pos and len are unkown so they also stored in a 4 byte register
 00000089				Val PROC uses EDX ESI EDI ;added uses, +12 to each ebp
 00000089  52		   *	    push   edx
 0000008A  56		   *	    push   esi
 0000008B  57		   *	    push   edi
 0000008C  55				push EBP
 0000008D  8B EC			mov EBP, ESP
					;--------------
 0000008F  8B 55 1C			mov edx, [ebp + 28]  ;position
 00000092  8B 75 18			mov esi, [ebp + 24]  ;len of string
 00000095  8B 7D 14			mov edi, [ebp + 20]   ;adress of string

 00000098  4E				dec esi ;len - 1
 00000099  3B D6			cmp edx, esi
 0000009B  76 04			JBE posInRnge
 0000009D  B0 00			mov al, 0
 0000009F  EB 06			jmp endOfFunction
 000000A1				posInRnge:
 000000A1  03 FA			add edi, edx
 000000A3  8A 07			mov al, BYTE PTR[edi]
 000000A5  2C 30			sub al, "0"
 000000A7				endOfFunction: 
					;---------------
 000000A7  8B E5			mov ESP, EBP
 000000A9  5D				pop EBP
 000000AA  5F		   *	    pop    edi
 000000AB  5E		   *	    pop    esi
 000000AC  5A		   *	    pop    edx
 000000AD  C2 000C			ret 12 ;make sure  is 8
 000000B0				Val ENDP

					;-------------------------------------
					;function explained: this function recives two strings and returns their sum (as a string)
					;registers used: parmeters: edi - adress of string a, edx - len a, esi -adress of string b, ebx - len b
					;eax- holds adress of res string, al temp for val returned from val func, ecx + edx + eax also used for div and
					;edi also used to hold modelu of div
					;adresses are 4 bytes, len are unkown so they are stored also in a 4 byte register

 000000B0				AddString PROC
 =-00000004				modeluTemp = -4
 000000B0  55				push EBP
 000000B1  8B EC			mov EBP, ESP
					;-------------
 000000B3  8B 45 18			mov EAX, [ebp + 24] ;ah is sum
 000000B6  8B 7D 14			mov edi, [ebp + 20] ;adress of string a
 000000B9  8B 55 10			mov edx, [ebp + 16]  ;len of string a
 000000BC  8B 75 0C			mov esi, [ebp + 12]  ;adress of string b
 000000BF  8B 5D 08			mov ebx, [ebp + 8]   ;len of string b
 000000C2  83 EC 04			sub esp, 4
 000000C5  83 EA 01			sub edx, 1  ; to get real size
 000000C8  83 EB 01			sub ebx, 1 ;to get real size
 000000CB  B9 00000000			mov ECX, 0 ;cl is t
 000000D0  BE 00000000			mov ESI, 0;ch is carry
 000000D5  8B C6			mov EAX, ESI  ;initalize sum to zero

 000000D7  8D 75 FC			lea esi, [EBP + modeluTemp]
 000000DA  46				inc esi;now we will put end of string symbol
 000000DB  C6 06 00			mov BYTE PTR[ESI], 0;modelu is of 10 so will always be 1- 9. only need 2 bytes
 000000DE  8B 75 0C			mov esi, [ebp + 12]  ;adress of string b
 000000E1  BE 00000000			mov esi, 0
 000000E6				addingStringLoop:
 000000E6  B9 00000000			mov ECX, 0 ;cl is t
 000000EB  52				push edx
 000000EC  53				push ebx
					;----------
 000000ED  50				push EAX
 000000EE  56				push ESI

 000000EF  52				push edx ;call val with A
 000000F0  FF 75 10			push [ebp + 16]
 000000F3  FF 75 14			push [ebp + 20]
 000000F6  E8 FFFFFF8E			call Val
 000000FB  0F B6 F0			movzx ESI , al
 000000FE  03 CE			add ECX, ESI

 00000100  53				push ebx
 00000101  FF 75 08			push [ebp + 8]
 00000104  FF 75 0C			push  [ebp + 12]
 00000107  E8 FFFFFF7D			call Val
 0000010C  0F B6 F0			movzx ESI, al
 0000010F  03 CE			add ECX, ESI ;t=val+ val
 00000111  5E				pop ESI

 00000112  58				pop EAX

 00000113  03 CE			add ECX, ESI ;add carry to t

					;push EDX
 00000115  50				push EAX
 00000116  BA 00000000			mov EDX, 0
 0000011B  8B C1			mov EAX, ECX ;moves t to EAX
 0000011D  B9 0000000A			mov ECX, 10
 00000122  F7 F1			div ECX 
 00000124  8B F0			mov ESI, EAX ; move carry to SI (t/10)
 00000126  5F				pop EDI ;holds value of sum
 00000127  57				push EDI
 00000128  56				push ESI
 00000129  8B 75 18			mov esi, [ebp + 24] ;puts sum in esi to send to function of pushback
 0000012C  8D 7D FC			lea EDI,[ebp + modeluTemp] 
					;mov al, BYTE PTR EDX
 0000012F  89 17			mov  [EDI], edx
 00000131  8A 07			mov al, BYTE PTR[EDI]
 00000133  04 30			add al, '0'
 00000135  88 07			mov BYTE PTR[EDI], al
				 
 00000137  E8 0000006E			call PushBack
 0000013C  5E				pop ESI
 0000013D  5F				pop EDI


					;add EDI, EDX ;adds modelu to sum
					;mov EAX, EDI
 0000013E  8B 45 18			mov EAX, [ebp + 24]
					;add EAX, "0" ;change to PUSH BACK
 00000141  5B				pop EBX
 00000142  5A				pop EDX
 00000143  83 EA 01			sub edx, 1
 00000146  83 EB 01			sub ebx, 1

 00000149  83 FA 00			cmp edx, 0
 0000014C  7D 98			JGE addingStringLoop
 0000014E  83 FB 00			cmp ebx, 0
 00000151  7D 93			JGE addingStringLoop

 00000153				lessThenZero:
 00000153  83 FE 00			cmp ESI, 0
 00000156  74 00			JZ endOfFunction
					

 00000158				endOfFunction:
 00000158  83 FE 00			cmp ESI, 0
 0000015B  74 14			JZ isZero
 0000015D  8B D6			mov edx, ESI
 0000015F  8B 75 18			mov ESI, [ebp + 24]
 00000162  8D 7D FC			lea EDI, [ebp + modeluTemp]
 00000165  89 17			mov  [EDI], edx
 00000167  83 C2 30			add EDX, '0'
 0000016A  89 17			mov [EDI], EDX
 0000016C  E8 00000039			call PushBack

 00000171				isZero:
 00000171  8B 75 18			mov ESI, [ebp + 24]
 00000174  E8 000000A5			call GetStringSize
 00000179  0F B6 CC			movzx ecx, ah
 0000017C  8B 75 18			mov ESI, [ebp + 24]
 0000017F  E8 00000009			call reverse_string

					;mov ESI, [ebp + 24]
					;call GetStringSize
					;makeStringLoop:
				;	mov cl, BYTE PTR [ESI]
					;add cl, '0'
					;mov [ESI], cl
					;inc ESI
					;dec ah
					;jnz makeStringLoop

					;mov ESI, [EBP+24] ;sum adress
					;call GetStringSize



 00000184  83 C4 04			add esp, 4
					;-------------
 00000187  8B E5			mov ESP, EBP
 00000189  5D				pop EBP
 0000018A  C2 0014			ret 20 ;make sure  is 8
 0000018D				AddString ENDP

 0000018D				reverse_string PROC USES ECX ESI EBX EDX
 0000018D  51		   *	    push   ecx
 0000018E  56		   *	    push   esi
 0000018F  53		   *	    push   ebx
 00000190  52		   *	    push   edx
 00000191  8B D1			mov edx, ecx	; save ECX for the second loop
 00000193			push_loop:
				    ; we can push either word or dword so we
				    ; copy the byte and extend it to a word
 00000193  8A 1E		    mov bl, [esi]
 00000195  66| 53		    push bx ; we push also MSB = bh, but we ignore it
 00000197  46				inc esi
 00000198  E2 F9		    loop push_loop
				    
				    ; now we pop all the values, in the same
				    ; order (i.e. the array from end to start)
				    ; ... but pop-push is actually reversing
					
 0000019A  8B CA		    mov ecx, edx		; restore the counter
 0000019C  2B F1			sub esi, ecx ; restore ESI
 0000019E			pop_loop:
 0000019E  66| 5B		    pop bx
 000001A0  88 1E		    mov [esi],bl
 000001A2  46				inc esi
 000001A3  E2 F9		    loop pop_loop 
					ret
 000001A5  5A		   *	    pop    edx
 000001A6  5B		   *	    pop    ebx
 000001A7  5E		   *	    pop    esi
 000001A8  59		   *	    pop    ecx
 000001A9  C3		   *	    ret    00000h
 000001AA			reverse_string ENDP

				;---------------------------------------------------
				;function explained: this function attaches a string to the end of another string (string b to the end of string a)
				;registers used: parameters: esi - string a adress, edi - string b adress. al, ah holds sized of strings. cl holds current char
				;of string b and ebx is used as temp for size
				;edi, esi holds adresses so they are 4 bytes each
 000001AA			PushBack PROC USES esi edi
 000001AA  56		   *	    push   esi
 000001AB  57		   *	    push   edi
 000001AC  57			push edi
 000001AD  E8 0000006C		call GetStringSize
 000001B2  8A C4		mov al, ah ;saves size of string in esi
 000001B4  56			push esi
 000001B5  8B F7		mov esi, edi
 000001B7  E8 00000062		call GetStringSize ;now size of string edi is in ah
 000001BC			skipThis:
 000001BC  5E			pop esi
 000001BD  5F			pop edi
 000001BE  0F B6 D8		movzx ebx, al ;check that works
				;dec ebx;for debugging
 000001C1  03 F3		add esi, ebx
				;inc esi
 000001C3  80 FC 00		cmp ah, 0
 000001C6  74 0D		jz emptyBstring
 000001C8			pushBackLoop:
 000001C8  8A 0F		mov cl, BYTE PTR [EDI]
				;mov ch, BYTE PTR [ESI] ;for debugging
 000001CA  88 0E		mov BYTE PTR [ESI], cl
 000001CC  46			inc ESI
 000001CD  47			inc EDI
 000001CE  FE CC		dec ah

 000001D0  75 F6		jnz pushBackLoop
 000001D2  C6 06 00		mov BYTE PTR[ESI], 0 ;end symbol
 000001D5			emptyBstring:
				ret
 000001D5  5F		   *	    pop    edi
 000001D6  5E		   *	    pop    esi
 000001D7  C3		   *	    ret    00000h
 000001D8			PushBack ENDP
				;-----------------------------------------------------

				;-----------------------------------------------------
				;function explained: this function attaches a string to the start of another string (string b to the start of string a)
				;registers used: parameters: esi - string a adress, edi - string b adress. al, ah holds sized of strings. cl holds current char
				;ebx holds temp string
				;edi, esi holds adresses so they are 4 bytes each
 000001D8			PushFront PROC USES esi edi
 000001D8  56		   *	    push   esi
 000001D9  57		   *	    push   edi
 000001DA  57			push edi
 000001DB  E8 0000003E		call GetStringSize
 000001E0  8A C4		mov al, ah ;saves size of string in esi
 000001E2  56			push esi
 000001E3  8B F7		mov esi, edi
 000001E5  E8 00000034		call GetStringSize ;now size of string edi is in ah
 000001EA  5E			pop esi
 000001EB  5F			pop edi
 000001EC  0F B6 DC		movzx ebx, ah ;check that works
				;dec ebx;for debugging
 000001EF  56			push esi
 000001F0  57			push edi
 000001F1  03 FB		add edi, ebx
				;inc esi
 000001F3  80 FC 00		cmp ah, 0
 000001F6  74 23		jz emptyBstring
 000001F8			pushFrontLoop:
 000001F8  8A 0E		mov cl, BYTE PTR [EsI]
				;mov ch, BYTE PTR [ESI] ;for debugging
 000001FA  88 0F		mov BYTE PTR [EdI], cl
 000001FC  46			inc ESI
 000001FD  47			inc EDI
 000001FE  FE C8		dec al
 00000200  75 F6		jnz pushFrontLoop
 00000202  C6 07 00		mov BYTE PTR[EDI], 0
 00000205  5F			pop edi

 00000206  8B F7		mov esi, edi
 00000208  E8 00000011		call GetStringSize
 0000020D  5E			pop esi
 0000020E			transferToAString:
 0000020E  8A 0F		mov cl, BYTE PTR[EDI]
 00000210  88 0E		mov BYTE PTR[ESI], cl
 00000212  47			inc edi
 00000213  46			inc esi
 00000214  FE CC		dec ah
 00000216  75 F6		jnz transferToAString
 00000218  C6 06 00		mov BYTE PTR[ESI], 0 ;end symbol
 0000021B			emptyBstring:
				ret
 0000021B  5F		   *	    pop    edi
 0000021C  5E		   *	    pop    esi
 0000021D  C3		   *	    ret    00000h
 0000021E			PushFront ENDP

				;-----------------------------------------------------------
				;function explained: this function recives adress offset string in esi and returns it's len in ah
				;registers used: esi holds the string adress, cl is temp for current charm ah holds res
				; esi holds adresses so it is 4 bytes 

 0000021E			GetStringSize PROC uses esi
 0000021E  56		   *	    push   esi
 0000021F  B4 00		mov ah, 0
 00000221			findsize:
 00000221  8A 0E		mov cl, BYTE PTR[ESI]
 00000223  80 3E 00		cmp BYTE PTR [esi], 0
 00000226  74 05		jz ending
 00000228  FE C4		inc ah
 0000022A  46			inc esi
 0000022B  EB F4		jmp findsize
 0000022D			ending:
				ret
 0000022D  5E		   *	    pop    esi
 0000022E  C3		   *	    ret    00000h
 0000022F			GetStringSize ENDP

				;----------------------------------------------------------------------
				;function explanation: this functon recives two strings and returns true/ false if they are equal or not
				;registers used: parameters: esi- first string adress, edi - second string adress, ch - holds string a size, ah - holds string b size
				;dl and dh - temp to hold current charecters in both strings. al returns true/false if strings are equel or not
				;edi, esi holds adresses so tehy are 4 bytes each
 0000022F			CmpStr PROC uses esi edi
 0000022F  56		   *	    push   esi
 00000230  57		   *	    push   edi
 00000231  E8 FFFFFFE8		call GetStringSize
 00000236  8A EC		mov ch, ah

 00000238  56			push esi
 00000239  8B F7		mov esi, edi
 0000023B  E8 FFFFFFDE		call GetStringSize

 00000240  5E			pop esi

 00000241  3A EC		cmp ch, ah
 00000243  75 12		JNZ ifNotEquel

 00000245  B0 01		mov al, 1 ;return 1 if not reached ifNotEquel
 00000247			cmpLoop:
 00000247  8A 16		mov dl, BYTE PTR[esi]
 00000249  8A 37		mov DH, BYTE PTR[edi]
 0000024B  3A D6		cmp dl, dh
 0000024D  75 08		jnz ifNotEquel
 0000024F  46			inc ESI
 00000250  47			inc EDI
 00000251  FE CC		dec ah
 00000253  75 F2		jnz cmpLoop

 00000255  EB 02		jmp EndOfLoop

 00000257			ifNotEquel:
 00000257  B0 00		mov al, 0 ;not same!

 00000259			EndOfLoop:

				ret
 00000259  5F		   *	    pop    edi
 0000025A  5E		   *	    pop    esi
 0000025B  C3		   *	    ret    00000h
 0000025C			CmpStr ENDP

				;----------------------------------------------------------------------------
				;function explanation: this function checks every iteration if adress of esi (first location in string) is equel to adress
				;of location of pos in string. if not - it will send to the next recurcive iteration esi++ and pos-- and will keep doing so until 
				;adress esi == adress pos. if equel - it will put into dest adress the sub string that starts at adress esi and with the required len

				;Registers used: parameters: esi-source, ecx-len of source, eax-pos, ebx-len, edi-dest
				;al returns true/false if substring found or not. ecx also used to hold adress of pos
				;all registers that holds adressed are 4 bytes, pos and len changes according to value (and this is why they are stored in a
				;4 byte register) 
 0000025C			SubString PROC USES ESI ECX EAX EBX EDI ;esi - source ecx - len of source eax- pos ebx - len edi - dest
 0000025C  56		   *	    push   esi
 0000025D  51		   *	    push   ecx
 0000025E  50		   *	    push   eax
 0000025F  53		   *	    push   ebx
 00000260  57		   *	    push   edi
 00000261  55				push EBP
 00000262  8B EC			mov EBP, ESP
					;------------
 00000264  8B 7D 2C			mov edi, [ebp + 44];dest adress  now holds source
 00000267  8B 4D 28			mov ecx, [ebp + 40] ;len of source
 0000026A  8B 45 24			mov eax, [ebp + 36] ;pos
 0000026D  8B 5D 20			mov ebx, [ebp + 32] ;len
 00000270  8B 75 1C			mov esi, [ebp + 28] ;source adress  origina;: 44 was souece and 28 was dest now holds dest

 00000273  8B 45 24			mov eax, [ebp + 36] ;eax = pos + len
 00000276  03 45 20			add eax, [ebp + 32]
 00000279  3B 45 28			cmp eax, [ebp + 40] ;maybe -1?
 0000027C  7F 2B			JG OutOfBoundSubString
 0000027E  51				push ecx
 0000027F  8B 45 24			mov eax, [ebp + 36] ;pos
 00000282  8B CE			mov ecx, esi
 00000284  03 C8			add ecx, eax ; now ecx holds adress of pos

 00000286  3B CE			cmp ecx, esi
 00000288  75 10			JNZ notEqual
 0000028A  59				pop ecx 
 0000028B  50				push eax;need to pop

 0000028C				insertSubStringToDes:
 0000028C  8A 06			mov al, BYTE PTR[EsI]
 0000028E  88 07			mov BYTE PTR [edi], al
 00000290  46				inc ESI
 00000291  47				inc EDI
 00000292  4B				dec EBX
 00000293  75 F7			JNZ insertSubStringToDes
 00000295  58				pop eax
 00000296  B0 01			mov al, 1 ;return true
 00000298  EB 11			jmp EndOfFunction

 0000029A				notEqual:
 0000029A  59			    pop ecx
 0000029B  46				inc ESI
 0000029C  48				dec EAX

 0000029D  57				push edi
 0000029E  51				push ecx
 0000029F  50				push eax
 000002A0  53				push ebx
 000002A1  56				push esi
 000002A2  E8 FFFFFFB5			call SubString ;RECURSIVE CALL
 000002A7  EB 02			 jmp EndOfFunction

 000002A9				OutOfBoundSubString:
 000002A9  B0 00			mov al, 0 ; return false


 000002AB				EndOfFunction:

					;-------------
 000002AB  8B E5			mov ESP, EBP
 000002AD  5D				pop EBP
 000002AE  5F		   *	    pop    edi
 000002AF  5B		   *	    pop    ebx
 000002B0  58		   *	    pop    eax
 000002B1  59		   *	    pop    ecx
 000002B2  5E		   *	    pop    esi
 000002B3  C2 0014			ret 20 ;make sure  is 8
 000002B6			SubString ENDP

				;------------------------------------------------------------------------------------------------
				;function explnation: this function looks for a combination of number sizes to see if there is a combination where the given
				;sequence is addetive
				;Registers used: esi holds adress of original string, edi adress of res string and edx size of original string
				;al boolean that returns true/false if the string is addetive or not
				;esi and edi both hokds adresses so they are 4 bytes, edx number of bytes changes according to size (1-4 bytes), but is send in a 4 
				;byte register to accomidate every possible size
 000002B6			IsAddSeq PROC uses ESI EDI EDX
 000002B6  56		   *	    push   esi
 000002B7  57		   *	    push   edi
 000002B8  52		   *	    push   edx
 000002B9  55			push EBP
 000002BA  8B EC		mov EBP, ESP
				;-------------
 =-0000000E			tempAstring = -(2*N)
 =-0000001C			tempBstring = -(4*N)
 =-0000002A			tempCstring = -(6*N)
 000002BC  8B 75 1C		mov ESI, [ebp + 28] ;adress of original str
 000002BF  8B 55 18		mov EDX, [EBP + 24] ; len of original str
 000002C2  8B 7D 14		mov EDI, [EBP + 20] ; res adress

 000002C5  83 EC 2A		sub esp, N*6 ;temp for 3 sub strings - a,b,c
 000002C8  BA 00000000		mov edx, 0
 000002CD  8D 75 F2		lea esi, [ebp + tempAstring]
 000002D0  C7 06 00000000	mov DWORD PTR [esi], 0
 000002D6  8D 75 E4		lea esi, [ebp + tempBstring]
 000002D9  C7 06 00000000	mov DWORD PTR [esi], 0
 000002DF  8D 75 D6		lea esi, [ebp + tempCstring]
 000002E2  C7 06 00000000	mov DWORD PTR [esi], 0

 000002E8  8B 45 18		mov eax, [EBP + 24]
 000002EB  48			dec eax; to get exact size
 000002EC  BA 00000000		mov EDX, 0 ;for div
 000002F1  B9 00000002		mov ecx, 2
 000002F6  F7 F1		div ecx ;now eax holds l/2
 000002F8  40			inc eax
				;to save l/2
 000002F9  BF 00000001		mov edi, 1 ;edx will be counter edx = i
 000002FE			outsideLoop:
 000002FE  50			push eax;to save val
 000002FF  8B 45 18		mov eax, [EBP + 24]
 00000302  48			dec eax
 00000303  2B C7		sub eax, edi ;l - i
 00000305  BA 00000000		mov EDX, 0 ;for div
 0000030A  B9 00000002		mov ecx, 2
 0000030F  F7 F1		div ecx ;now eax holds l-i/2
 00000311  40			inc eax
 00000312  8B C8		mov ecx, eax
 00000314  BB 00000001		mov ebx, 1 ;ebx counter = j
 00000319  58			pop eax
 0000031A			innerLoop:
 0000031A  8D 75 F2		lea esi, [ebp + tempAstring]
				;testtttttt
 0000031D  51			push ecx
 0000031E  57			push edi
 0000031F  8D 7D E4		lea edi, [ebp + tempBstring]
 00000322  B1 0E		mov cl, N*2
 00000324			emptyTempsLoop:
 00000324  C6 06 00		mov BYTE PTR[ESI], 0
 00000327  C6 07 00		mov BYTE PTR[EDI], 0
 0000032A  46			inc esi
 0000032B  47			inc edi
 0000032C  FE C9		dec cl
 0000032E  75 F4		jnz emptyTempsLoop
 00000330  5F			pop edi
 00000331  59			pop ecx
				;----------------------------testt
 00000332  C7 06 00000000	mov DWORD PTR [esi], 0
 00000338  8D 75 D6		lea esi, [ebp + tempCstring]
 0000033B  C7 06 00000000	mov DWORD PTR [esi], 0
 00000341  51			push ecx
					;creating a substring
 00000342  8D 75 F2			lea esi, [ebp + tempAstring]
 00000345  56				push esi;dest for a string
 00000346  8B 75 18			mov esi,  [EBP + 24]
 00000349  56				push esi; len of string source
 0000034A  BE 00000000			mov esi, 0
 0000034F  56				push esi ;pos = 0
 00000350  57				push edi ;len = i
 00000351  8B 75 1C				mov ESI, [ebp + 28]
 00000354  56				push esi; original string
 00000355  E8 FFFFFF02			call SubString ;now esp - N holds a sub string

					;creating b substring
 0000035A  8D 75 E4			lea esi, [ebp + tempBstring]; temp for b substring
 0000035D  56				push esi
 0000035E  8B 75 18			mov esi,  [EBP + 24]
 00000361  56				push esi; len of string source
 00000362  57				push edi ; pos = i
 00000363  53				push ebx ; len = j
 00000364  8B 75 1C			 mov ESI, [ebp + 28]
 00000367  56				push esi; original string
 00000368  E8 FFFFFEEF			call SubString

 0000036D  57				push edi
					;creatung c substring
 0000036E  8D 75 D6			lea esi, [ebp + tempCstring]; temp for c substring
 00000371  56				push esi
 00000372  8B 75 18			mov esi,  [EBP + 24]
 00000375  56				push esi;size of original string
 00000376  8B F3			mov esi, ebx ;esi = J
 00000378  03 F7			add esi, edi ;esi = j + i
 0000037A  56				push esi ;pos = i + j
 0000037B  8B 7D 18			mov edi, [EBP + 24]
 0000037E  2B FE			sub edi, esi ;size of original - (i+j) = len
 00000380  57				push edi ;len
 00000381  8B 75 1C			  mov ESI, [ebp + 28]
 00000384  56				push esi; original string
 00000385  E8 FFFFFED2			call SubString
 0000038A  5F				pop edi

 0000038B  50			push eax; to save value	
 0000038C  53			push ebx; to save value
 0000038D  57			push edi; to save value
				;call check adition
 0000038E  8D 75 F2			lea esi, [ebp + tempAstring];a subtring
 00000391  8D 7D E4			lea edi, [ebp + tempBstring]; b string
 00000394  8D 45 D6			lea eax, [ebp + tempCstring];c string
 00000397  56				push esi
 00000398  57			push edi
 00000399  50			push eax
 0000039A  8B 75 1C		mov ESI, [EBP + 28]
 0000039D  56			push ESI ; adress of original str
 0000039E  8B 75 18		mov ESI, [EBP + 24] 
 000003A1  56			push ESI ;len of original str
 000003A2  BE 00000007 R	mov ESI, OFFSET res
				;------------make res empty
 000003A7  B1 0F		mov cl, N*2+1 
 000003A9			makeEmptyLoop:
 000003A9  C6 06 00		mov BYTE PTR[ESI], 0
 000003AC  46			inc esi
 000003AD  FE C9		dec cl
 000003AF  75 F8		jnz makeEmptyLoop
				;-----------------------
 000003B1  BE 00000007 R	mov ESI, OFFSET res

 000003B6  56			push esi ;adress of res
 000003B7  E8 00000082		call ChkAddition
 000003BC  5F			pop edi
 000003BD  5B			pop ebx

 000003BE  3C 01		cmp al, 1
 000003C0  75 50		JNZ returendZero
 000003C2  BE 00000007 R	mov esi, OFFSET res
 000003C7  8D 7D D6		lea edi, [EBP + tempCstring]

 000003CA  B4 07		mov ah, N
 000003CC			loopMakeEmpty:
 000003CC  C6 07 00		mov BYTE PTR[edi], 0
 000003CF  47			inc edi
 000003D0  FE CC		dec ah
 000003D2  75 F8		jnz loopMakeEmpty

 000003D4  8D 7D D6		lea edi, [EBP + tempCstring]
 000003D7  C6 07 20		mov BYTE PTR[EdI], " "
 000003DA  E8 FFFFFDF9		call PushFront
 000003DF  BE 00000007 R	mov esi, OFFSET RES
 000003E4  8D 7D E4		lea edi, [EBP + tempBstring] ;adress of temp b
 000003E7  E8 FFFFFDEC		call PushFront ;push front of b to res 

 000003EC  BE 00000007 R	mov esi, OFFSET res
 000003F1  8D 7D D6		lea edi, [EBP + tempCstring]
 000003F4  C6 07 20		mov BYTE PTR[EDI], " "
 000003F7  47			inc edi
 000003F8  C6 07 00		mov BYTE PTR[EDI], 0
 000003FB  8D 7D D6		lea edi, [EBP + tempCstring]
 000003FE  E8 FFFFFDD5		call PushFront
 00000403  BE 00000007 R	mov esi, OFFSET RES
 00000408  8D 7D F2		lea edi, [EBP + tempAstring] ;adress of temp b
 0000040B  E8 FFFFFDC8		call PushFront
 00000410  EB 20		jmp endOfFuncSuccesful
 00000412			returendZero:
 00000412  58			pop eax
 00000413  59			pop ecx
 00000414  43			inc ebx
 00000415  3B D9		cmp ebx, ecx
 00000417  0F 85 FFFFFEFD	jnz innerLoop

				;pop eax ;ecx holds value
 0000041D  47			inc edi
 0000041E  3B F8		cmp edi, eax
 00000420  0F 85 FFFFFED8	jnz OutsideLoop

 00000426  BE 00000007 R	mov esi, OFFSET res ;res.clear()
 0000042B  BA 00000000		mov edx, 0
 00000430  89 16		mov DWORD PTR [esi], edx

 00000432			endOfFuncSuccesful:

 00000432  83 C4 2A		add esp, N*6
				;---------------
 00000435  8B E5		mov ESP, EBP
 00000437  5D			pop EBP
 00000438  5A		   *	    pop    edx
 00000439  5F		   *	    pop    edi
 0000043A  5E		   *	    pop    esi
 0000043B  C2 000C		ret 12 
 0000043E			IsAddSeq ENDP 
				;-------------------------------------------------------------------------------------------------------------
				;function explanation: this function checks if a string is addetive or not
				;registers used: parameters: esi - adress of original str, eax - size of original str, edi - res adress, edx - a string
				;ebx - b string, ecx - c string. esi and edi also used to send parameters to inner functions like get size for exmple.
				;in this func we aldo allocated memory for local var on the stack (two strings with len N - one for sun and one for temp)
				;all parameters were send in full registers and so they take 4 bytes (adresses for exmple). size of string can take less bytes,
				;depending on size but is send in a 4 byte register becouse size is unknown 
 0000043E			ChkAddition PROC 
 =-00000007			sum1 = -N
 =-0000000E			temp1 = -(2*N)
 0000043E  55			push EBP
 0000043F  8B EC		mov EBP, ESP
				;----------------------------
 00000441  8B 55 1C		mov EDX, [EBP + 28];a string
 00000444  8B 5D 18		mov EBX, [EBP + 24];b string
 00000447  8B 4D 14		mov ECX, [ebp + 20];c string
 0000044A  8B 75 10		mov ESI, [EBP + 16] ;adress original string
 0000044D  8B 45 0C		mov EAX, [EBP + 12] ;size of original string
 00000450  8B 7D 08		mov EDI, [EBP + 8] ;result

 00000453  83 EC 0E		sub ESP, N * 2 ; [ebp - n] is res adress, [ebp - n*2] is temp adress used later in function
 00000456  B4 07		mov ah, N

 00000458  8D 75 F2		lea esi, [EBP + TEMP1]
 0000045B  8D 7D F9		lea edi, [EBP + SUM1]
 0000045E			loopMakeEmpty:
 0000045E  C6 06 00		mov BYTE PTR [ESI], 0
 00000461  C6 07 00		mov BYTE PTR [EDI], 0
 00000464  46			inc esi 
 00000465  47			inc edi
 00000466  FE CC		dec ah
 00000468  75 F4		jnz loopMakeEmpty



 0000046A  8B 75 1C		mov ESI, [EBP + 28] ; check if a is valid
 0000046D  E8 FFFFFDAC		call GetStringSize
 00000472  0F B6 D4		movzx edx, ah
 00000475  52			push edx ;len of a
 00000476  56			push ESI; adress of a
 00000477  E8 FFFFFBEA		call IsValid
 0000047C  3C 00		cmp al, 0
 0000047E  0F 84 00000147	JZ EndOfFunction 

 00000484  8B 75 18		mov ESI, [EBP + 24] ; check if b is valid
 00000487  E8 FFFFFD92		call GetStringSize
 0000048C  0F B6 D4		movzx edx, ah
 0000048F  52			push edx ;len of a
 00000490  56			push ESI; adress of a
 00000491  E8 FFFFFBD0		call IsValid
 00000496  3C 00		cmp al, 0
 00000498  0F 84 0000012D	JZ EndOfFunction 

 0000049E  8B 45 0C		mov EAX, [EBP + 12] ;size of original string

 000004A1  B4 07		mov ah, N
 000004A3  8D 75 F2		lea ESI, [ebp + temp1] ;sum that is allocated in stack adress
 000004A6  8D 7D F9		lea EDI, [ebp + sum1]
				;need to make it all zero so itll be empty/try to check without the add esi N
				;--------------------------------------------------------------------------------------------------
				;params for addString
 000004A9  8D 75 F9		lea ESI, [EBP + SUM1]
 000004AC  56			push ESI; adress of sum 
				;sending parameter list to addd string
 000004AD  8B 55 1C		mov EDX, [EBP + 28]
 000004B0  52			push EDX ;adress string a
 000004B1  8B 75 1C		mov ESI, [EBP + 28]
 000004B4  E8 FFFFFD65		call GetStringSize
 000004B9  0F B6 D4		movzx EDX, ah
 000004BC  52			push EDX ;size string a
 000004BD  8B 75 18		mov ESI, [EBP + 24]
 000004C0  56			push ESI ; adress of b
 000004C1  E8 FFFFFD58		call GetStringSize
 000004C6  0F B6 F4		movzx ESI, ah
 000004C9  56			push ESI ; size of b
 000004CA  E8 FFFFFBE1		call AddString

 000004CF  8B 7D 14		mov edi, [EBP + 20];c string
				;esi holds sum 

 000004D2  8D 75 F9		lea esi, [EBP + SUM1];HHOLDS SUM

 000004D5  E8 FFFFFD55		call CmpStr

 000004DA  3C 01		cmp al, 1 ;if c == sum 
 000004DC  75 20		JNZ notEqual
 000004DE  8B 75 08		mov esi, [ebp + 8] ;adress of res
 000004E1  8D 7D F9		LEA edi, [EBP + SUM1] ;adress of sum
 000004E4  E8 FFFFFCC1		call PushBack 
 000004E9  8D 7D F2		lea edi, [EBP + temp1]
 000004EC  8B 75 08		mov esi, [ebp + 8] ;adress of res
 000004EF  C6 07 20		mov BYTE PTR [edi], " "
 000004F2  E8 FFFFFCB3		call PushBack

 000004F7  B0 01		mov al, 1 
 000004F9  E9 000000CD		jmp EndOfFunction;:;need to make sure al keeps res value 
 000004FE			notEqual: 
 000004FE  8B 75 14		mov ESI, [EBP + 20] ;adress of c
 00000501  E8 FFFFFD18		call GetStringSize
 00000506  8A C4		mov al, ah ;not al holds size of string c
 00000508  8D 75 F9		LEA ESI, [EBP + SUM1]
 0000050B  E8 FFFFFD0E		call GetStringSize ;now ah holds size of sum
 00000510  3A C4		cmp al, ah
 00000512  0F 8E 000000AA	JLE returnFalse

				;params for subString
 00000518  8D 75 F2		LEA esi, [EBP + TEMP1];adress of temp to save res of subStr function
 0000051B  BA 00000000		mov edx, 0
 00000520  89 16		mov [esi], edx ;make sure is empty
 00000522  56			push esi
 00000523  0F B6 F0		movzx esi, al
 00000526  56			push ESI ; sends size of c
 00000527  BE 00000000		mov esi, 0
 0000052C  56			push esi ; sends pos = 0
 0000052D  0F B6 F4		movzx esi, ah 
 00000530  56			push esi; size of sum sending as len
 00000531  8B 75 14		mov ESI, [ebp + 20] ; c adress
 00000534  56			push esi;send adress of c

 00000535  E8 FFFFFD22		call SubString

 0000053A  8D 75 F9		lea ESI, [ebp + SUM1] ;now ESI holds sum
 0000053D  8D 7D F2		lea EDI, [EBP + temp1];now edi holds adress of temp that returned from substr

 00000540  E8 FFFFFCEA		call CmpStr 

 00000545  3C 00		cmp al, 0 ;sum != c.substr(0, sum.size()
 00000547  74 79		JZ returnFalse

 00000549  8D 7D F2		lea EDI, [EBP + temp1]
 0000054C  B4 07		mov ah, N
 0000054E			loopMakeEmpty2:
 0000054E  C6 07 00		mov BYTE PTR [EDI], 0
 00000551  47			inc edi
 00000552  FE CC		dec ah
 00000554  75 F8		jnz loopMakeEmpty2

 00000556  8B 75 08		mov esi, [ebp + 8] ;adress of res
 00000559  8D 7D F9		lea edi, [EBP + SUM1] ;adress of sum
 0000055C  E8 FFFFFC49		call PushBack 
 00000561  8D 7D F2		lea edi, [EBP + temp1]
 00000564  8B 75 08		mov esi, [ebp + 8] ;adress of res
 00000567  C6 07 20		mov BYTE PTR [edi], " "
 0000056A  E8 FFFFFC3B		call PushBack

				;now we need to get c.substr(sum.size())
 0000056F  8D 75 F2		lea esi, [ebp + temp1] ;adress of temp to save res of subStr function
 00000572  BA 00000000		mov edx, 0
 00000577  89 16		mov [esi], edx ;make sure is empty
 00000579  56			push esi ; sends temp adress to get substring res in temp
 0000057A  8B 75 14		mov ESI, [EBP + 20]
 0000057D  E8 FFFFFC9C		call GetStringSize
 00000582  8A C4		mov al, ah;size of c in al
 00000584  0F B6 F4		movzx esi, ah
 00000587  56			push ESI ; sends size of c
 00000588  8D 75 F9		lea esi, [EBP + SUM1]
 0000058B  E8 FFFFFC8E		call GetStringSize
 00000590  0F B6 F4		movzx esi, ah ; ah = size of sum
 00000593  56			push esi ; sends pos = size of sum
 00000594  0F B6 D4		movzx edx, ah ; now edx holds pos
 00000597  0F B6 F0		movzx esi, al;size of c
 0000059A  2B F2		sub esi, edx ;size of c - pos
 0000059C  56			push esi; sends len (pos until end o c)
 0000059D  8B 75 14		mov ESI, [ebp + 20] ; c adress
 000005A0  56			push esi;send adress of c
 000005A1  E8 FFFFFCB6		call SubString


				;now params for recursive call
 000005A6  8B 7D 18		mov edi, [EBP + 24]
 000005A9  8D 75 F9		lea esi, [ebp + sum1]
 000005AC  8D 55 F2		lea edx, [ebp + temp1]
 000005AF  57			push edi ;send b string as a string
 000005B0  56			push esi ;sends sum as b string
 000005B1  52			push edx;sends ,c.substr(sum.size()) as c string
 000005B2  8B 75 10		mov esi, [EBP + 16]
 000005B5  56			push esi;address of original string
 000005B6  8B 75 0C		mov esi, [EBP + 12]
 000005B9  56			push esi; size of original str
 000005BA  BE 00000007 R	mov esi, OFFSET res
 000005BF  56			push esi
 000005C0  EB 04		jmp recursiceCall

 000005C2			returnFalse:
 000005C2  B0 00		mov al, 0
 000005C4  EB 05		jmp EndOfFunction

 000005C6			recursiceCall:
 000005C6  E8 FFFFFE73		call ChkAddition

 000005CB			EndOfFunction:
 000005CB  83 C4 0E		add esp, N*2
				;----------------------
 000005CE  8B E5			mov ESP, EBP
 000005D0  5D				pop EBP
 000005D1  C2 0018			ret 24 
 000005D4			ChkAddition ENDP 


						END main
						

	
Microsoft (R) Macro Assembler Version 14.28.29913.0	    07/07/21 23:31:08
asm3_Q3.asm						     Symbols 2 - 1




Structures and Unions:

                N a m e                  Size
                                         Offset      Type

CONSOLE_CURSOR_INFO  . . . . . .	 00000008
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  bVisible . . . . . . . . . . .	 00000004	 DWord
CONSOLE_SCREEN_BUFFER_INFO . . .	 00000016
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  dwCursorPosition . . . . . . .	 00000004	 DWord
  wAttributes  . . . . . . . . .	 00000008	 Word
  srWindow . . . . . . . . . . .	 0000000A	 QWord
  dwMaximumWindowSize  . . . . .	 00000012	 DWord
COORD  . . . . . . . . . . . . .	 00000004
  X  . . . . . . . . . . . . . .	 00000000	 Word
  Y  . . . . . . . . . . . . . .	 00000002	 Word
FILETIME . . . . . . . . . . . .	 00000008
  loDateTime . . . . . . . . . .	 00000000	 DWord
  hiDateTime . . . . . . . . . .	 00000004	 DWord
FOCUS_EVENT_RECORD . . . . . . .	 00000004
  bSetFocus  . . . . . . . . . .	 00000000	 DWord
FPU_ENVIRON  . . . . . . . . . .	 0000001C
  controlWord  . . . . . . . . .	 00000000	 Word
  statusWord . . . . . . . . . .	 00000004	 Word
  tagWord  . . . . . . . . . . .	 00000008	 Word
  instrPointerOffset . . . . . .	 0000000C	 DWord
  instrPointerSelector . . . . .	 00000010	 DWord
  operandPointerOffset . . . . .	 00000014	 DWord
  operandPointerSelector . . . .	 00000018	 Word
INPUT_RECORD . . . . . . . . . .	 00000014
  EventType  . . . . . . . . . .	 00000000	 Word
  Event  . . . . . . . . . . . .	 00000004	 XmmWord
  bKeyDown . . . . . . . . . . .	 00000000	 DWord
  wRepeatCount . . . . . . . . .	 00000004	 Word
  wVirtualKeyCode  . . . . . . .	 00000006	 Word
  wVirtualScanCode . . . . . . .	 00000008	 Word
  uChar  . . . . . . . . . . . .	 0000000A	 Word
  UnicodeChar  . . . . . . . . .	 00000000	 Word
  AsciiChar  . . . . . . . . . .	 00000000	 Byte
  dwControlKeyState  . . . . . .	 0000000C	 DWord
  dwMousePosition  . . . . . . .	 00000000	 DWord
  dwButtonState  . . . . . . . .	 00000004	 DWord
  dwMouseControlKeyState . . . .	 00000008	 DWord
  dwEventFlags . . . . . . . . .	 0000000C	 DWord
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  dwCommandId  . . . . . . . . .	 00000000	 DWord
  bSetFocus  . . . . . . . . . .	 00000000	 DWord
KEY_EVENT_RECORD . . . . . . . .	 00000010
  bKeyDown . . . . . . . . . . .	 00000000	 DWord
  wRepeatCount . . . . . . . . .	 00000004	 Word
  wVirtualKeyCode  . . . . . . .	 00000006	 Word
  wVirtualScanCode . . . . . . .	 00000008	 Word
  uChar  . . . . . . . . . . . .	 0000000A	 Word
  UnicodeChar  . . . . . . . . .	 00000000	 Word
  AsciiChar  . . . . . . . . . .	 00000000	 Byte
  dwControlKeyState  . . . . . .	 0000000C	 DWord
MENU_EVENT_RECORD  . . . . . . .	 00000004
  dwCommandId  . . . . . . . . .	 00000000	 DWord
MOUSE_EVENT_RECORD . . . . . . .	 00000010
  dwMousePosition  . . . . . . .	 00000000	 DWord
  dwButtonState  . . . . . . . .	 00000004	 DWord
  dwMouseControlKeyState . . . .	 00000008	 DWord
  dwEventFlags . . . . . . . . .	 0000000C	 DWord
SMALL_RECT . . . . . . . . . . .	 00000008
  Left . . . . . . . . . . . . .	 00000000	 Word
  Top  . . . . . . . . . . . . .	 00000002	 Word
  Right  . . . . . . . . . . . .	 00000004	 Word
  Bottom . . . . . . . . . . . .	 00000006	 Word
SYSTEMTIME . . . . . . . . . . .	 00000010
  wYear  . . . . . . . . . . . .	 00000000	 Word
  wMonth . . . . . . . . . . . .	 00000002	 Word
  wDayOfWeek . . . . . . . . . .	 00000004	 Word
  wDay . . . . . . . . . . . . .	 00000006	 Word
  wHour  . . . . . . . . . . . .	 00000008	 Word
  wMinute  . . . . . . . . . . .	 0000000A	 Word
  wSecond  . . . . . . . . . . .	 0000000C	 Word
  wMilliseconds  . . . . . . . .	 0000000E	 Word
WINDOW_BUFFER_SIZE_RECORD  . . .	 00000004
  dwSize . . . . . . . . . . . .	 00000000	 DWord


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00001000 Para	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 00000031 Para	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 000005D4 Para	  Public  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

AddString  . . . . . . . . . . .	P Near	 000000B0 _TEXT	Length= 000000DD Public STDCALL
  addingStringLoop . . . . . . .	L Near	 000000E6 _TEXT	
  lessThenZero . . . . . . . . .	L Near	 00000153 _TEXT	
  endOfFunction  . . . . . . . .	L Near	 00000158 _TEXT	
  isZero . . . . . . . . . . . .	L Near	 00000171 _TEXT	
ChkAddition  . . . . . . . . . .	P Near	 0000043E _TEXT	Length= 00000196 Public STDCALL
  loopMakeEmpty  . . . . . . . .	L Near	 0000045E _TEXT	
  notEqual . . . . . . . . . . .	L Near	 000004FE _TEXT	
  loopMakeEmpty2 . . . . . . . .	L Near	 0000054E _TEXT	
  returnFalse  . . . . . . . . .	L Near	 000005C2 _TEXT	
  recursiceCall  . . . . . . . .	L Near	 000005C6 _TEXT	
  EndOfFunction  . . . . . . . .	L Near	 000005CB _TEXT	
CloseFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CloseHandle  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Clrscr . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CmpStr . . . . . . . . . . . . .	P Near	 0000022F _TEXT	Length= 0000002D Public STDCALL
  cmpLoop  . . . . . . . . . . .	L Near	 00000247 _TEXT	
  ifNotEquel . . . . . . . . . .	L Near	 00000257 _TEXT	
  EndOfLoop  . . . . . . . . . .	L Near	 00000259 _TEXT	
CreateFileA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateOutputFile . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Crlf . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Delay  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DumpMem  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DumpRegs . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ExitProcess  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToDosDateTime  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToSystemTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FlushConsoleInputBuffer  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FormatMessageA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandLineA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandTail . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCP . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleScreenBufferInfo . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDateTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFileTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetKeyState  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLastError . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMaxXY . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMseconds  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNumberOfConsoleInputEvents  .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessHeap . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetStdHandle . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetStringSize  . . . . . . . . .	P Near	 0000021E _TEXT	Length= 00000011 Public STDCALL
  findsize . . . . . . . . . . .	L Near	 00000221 _TEXT	
  ending . . . . . . . . . . . .	L Near	 0000022D _TEXT	
GetSystemTime  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTextColor . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTickCount . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Gotoxy . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapAlloc  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapCreate . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapDestroy  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapFree . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapSize . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsAddSeq . . . . . . . . . . . .	P Near	 000002B6 _TEXT	Length= 00000188 Public STDCALL
  outsideLoop  . . . . . . . . .	L Near	 000002FE _TEXT	
  innerLoop  . . . . . . . . . .	L Near	 0000031A _TEXT	
  emptyTempsLoop . . . . . . . .	L Near	 00000324 _TEXT	
  makeEmptyLoop  . . . . . . . .	L Near	 000003A9 _TEXT	
  loopMakeEmpty  . . . . . . . .	L Near	 000003CC _TEXT	
  returendZero . . . . . . . . .	L Near	 00000412 _TEXT	
  endOfFuncSuccesful . . . . . .	L Near	 00000432 _TEXT	
IsDigit  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsValid  . . . . . . . . . . . .	P Near	 00000066 _TEXT	Length= 00000023 Public STDCALL
  notGreater . . . . . . . . . .	L Near	 0000007F _TEXT	
  notEquel . . . . . . . . . . .	L Near	 0000007F _TEXT	
  endOfFunction  . . . . . . . .	L Near	 00000081 _TEXT	
LocalFree  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MessageBoxA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MsgBoxAsk  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MsgBox . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenInputFile  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ParseDecimal32 . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ParseInteger32 . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PeekConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PushBack . . . . . . . . . . . .	P Near	 000001AA _TEXT	Length= 0000002E Public STDCALL
  skipThis . . . . . . . . . . .	L Near	 000001BC _TEXT	
  pushBackLoop . . . . . . . . .	L Near	 000001C8 _TEXT	
  emptyBstring . . . . . . . . .	L Near	 000001D5 _TEXT	
PushFront  . . . . . . . . . . .	P Near	 000001D8 _TEXT	Length= 00000046 Public STDCALL
  pushFrontLoop  . . . . . . . .	L Near	 000001F8 _TEXT	
  transferToAString  . . . . . .	L Near	 0000020E _TEXT	
  emptyBstring . . . . . . . . .	L Near	 0000021B _TEXT	
Random32 . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RandomRange  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Randomize  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadChar . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadDec  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFile . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFloat  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFromFile . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadHex  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadInt  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadKeyFlush . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadKey  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadString . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorPosition . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleScreenBufferSize . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTextAttribute  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTitleA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleWindowInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFilePointer . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetTextColor . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ShowFPUStack . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Sleep  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StrLength  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_compare  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_copy . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_length . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_trim . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_ucase  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SubString  . . . . . . . . . . .	P Near	 0000025C _TEXT	Length= 0000005A Public STDCALL
  insertSubStringToDes . . . . .	L Near	 0000028C _TEXT	
  notEqual . . . . . . . . . . .	L Near	 0000029A _TEXT	
  OutOfBoundSubString  . . . . .	L Near	 000002A9 _TEXT	
  EndOfFunction  . . . . . . . .	L Near	 000002AB _TEXT	
SystemTimeToFileTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Val  . . . . . . . . . . . . . .	P Near	 00000089 _TEXT	Length= 00000027 Public STDCALL
  posInRnge  . . . . . . . . . .	L Near	 000000A1 _TEXT	
  endOfFunction  . . . . . . . .	L Near	 000000A7 _TEXT	
WaitMsg  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteBinB  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteBin . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteChar  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputAttribute  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputCharacterA . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteDec . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFloat . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteHexB  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteHex . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteInt . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteStackFrameName  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteStackFrame  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteString  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteToFile  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteWindowsMsg  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
main . . . . . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 00000066 Public STDCALL
  ReturnedFalse  . . . . . . . .	L Near	 00000055 _TEXT	
  endMain  . . . . . . . . . . .	L Near	 0000005F _TEXT	
printf . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
reverse_string . . . . . . . . .	P Near	 0000018D _TEXT	Length= 0000001D Public STDCALL
  push_loop  . . . . . . . . . .	L Near	 00000193 _TEXT	
  pop_loop . . . . . . . . . . .	L Near	 0000019E _TEXT	
scanf  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
wsprintfA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000003h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
ALT_MASK . . . . . . . . . . . .	Number	 00000003h   
CAPSLOCK_ON  . . . . . . . . . .	Number	 00000080h   
CREATE_ALWAYS  . . . . . . . . .	Number	 00000002h   
CREATE_NEW . . . . . . . . . . .	Number	 00000001h   
CTRL_MASK  . . . . . . . . . . .	Number	 0000000Ch   
CreateFile . . . . . . . . . . .	Text   	 CreateFileA
DO_NOT_SHARE . . . . . . . . . .	Number	 00000000h   
ENABLE_ECHO_INPUT  . . . . . . .	Number	 00000004h   
ENABLE_LINE_INPUT  . . . . . . .	Number	 00000002h   
ENABLE_MOUSE_INPUT . . . . . . .	Number	 00000010h   
ENABLE_PROCESSED_INPUT . . . . .	Number	 00000001h   
ENABLE_PROCESSED_OUTPUT  . . . .	Number	 00000001h   
ENABLE_WINDOW_INPUT  . . . . . .	Number	 00000008h   
ENABLE_WRAP_AT_EOL_OUTPUT  . . .	Number	 00000002h   
ENHANCED_KEY . . . . . . . . . .	Number	 00000100h   
FALSE  . . . . . . . . . . . . .	Number	 00000000h   
FILE_APPEND_DATA . . . . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_ARCHIVE . . . . .	Number	 00000020h   
FILE_ATTRIBUTE_COMPRESSED  . . .	Number	 00000800h   
FILE_ATTRIBUTE_DEVICE  . . . . .	Number	 00000040h   
FILE_ATTRIBUTE_DIRECTORY . . . .	Number	 00000010h   
FILE_ATTRIBUTE_ENCRYPTED . . . .	Number	 00004000h   
FILE_ATTRIBUTE_HIDDEN  . . . . .	Number	 00000002h   
FILE_ATTRIBUTE_NORMAL  . . . . .	Number	 00000080h   
FILE_ATTRIBUTE_NOT_CONTENT_INDEXED .	Number	 00002000h   
FILE_ATTRIBUTE_OFFLINE . . . . .	Number	 00001000h   
FILE_ATTRIBUTE_READONLY  . . . .	Number	 00000001h   
FILE_ATTRIBUTE_REPARSE_POINT . .	Number	 00000400h   
FILE_ATTRIBUTE_SPARSE_FILE . . .	Number	 00000200h   
FILE_ATTRIBUTE_SYSTEM  . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_TEMPORARY . . . .	Number	 00000100h   
FILE_BEGIN . . . . . . . . . . .	Number	 00000000h   
FILE_CURRENT . . . . . . . . . .	Number	 00000001h   
FILE_DELETE_CHILD  . . . . . . .	Number	 00000040h   
FILE_END . . . . . . . . . . . .	Number	 00000002h   
FILE_READ_DATA . . . . . . . . .	Number	 00000001h   
FILE_SHARE_DELETE  . . . . . . .	Number	 00000004h   
FILE_SHARE_READ  . . . . . . . .	Number	 00000001h   
FILE_SHARE_WRITE . . . . . . . .	Number	 00000002h   
FILE_WRITE_DATA  . . . . . . . .	Number	 00000002h   
FOCUS_EVENT  . . . . . . . . . .	Number	 00000010h   
FORMAT_MESSAGE_ALLOCATE_BUFFER .	Number	 00000100h   
FORMAT_MESSAGE_FROM_SYSTEM . . .	Number	 00001000h   
FormatMessage  . . . . . . . . .	Text   	 FormatMessageA
GENERIC_ALL  . . . . . . . . . .	Number	 10000000h   
GENERIC_EXECUTE  . . . . . . . .	Number	 20000000h   
GENERIC_READ . . . . . . . . . .	Number	 -80000000h   
GENERIC_WRITE  . . . . . . . . .	Number	 40000000h   
GetCommandLine . . . . . . . . .	Text   	 GetCommandLineA
HANDLE . . . . . . . . . . . . .	Text   	 DWORD
HEAP_GENERATE_EXCEPTIONS . . . .	Number	 00000004h   
HEAP_GROWABLE  . . . . . . . . .	Number	 00000002h   
HEAP_NO_SERIALIZE  . . . . . . .	Number	 00000001h   
HEAP_REALLOC_IN_PLACE_ONLY . . .	Number	 00000010h   
HEAP_ZERO_MEMORY . . . . . . . .	Number	 00000008h   
IDABORT  . . . . . . . . . . . .	Number	 00000003h   
IDCANCEL . . . . . . . . . . . .	Number	 00000002h   
IDCLOSE  . . . . . . . . . . . .	Number	 00000008h   
IDCONTINUE . . . . . . . . . . .	Number	 0000000Bh   
IDHELP . . . . . . . . . . . . .	Number	 00000009h   
IDIGNORE . . . . . . . . . . . .	Number	 00000005h   
IDNO . . . . . . . . . . . . . .	Number	 00000007h   
IDOK . . . . . . . . . . . . . .	Number	 00000001h   
IDRETRY  . . . . . . . . . . . .	Number	 00000004h   
IDTIMEOUT  . . . . . . . . . . .	Number	 00007D00h   
IDTRYAGAIN . . . . . . . . . . .	Number	 0000000Ah   
IDYES  . . . . . . . . . . . . .	Number	 00000006h   
INVALID_HANDLE_VALUE . . . . . .	Number	 -00000001h   
Input  . . . . . . . . . . . . .	Byte	 00000016 _DATA	
KBDOWN_FLAG  . . . . . . . . . .	Number	 00000001h   
KEY_EVENT  . . . . . . . . . . .	Number	 00000001h   
KEY_MASKS  . . . . . . . . . . .	Number	 0000001Fh   
LEFT_ALT_PRESSED . . . . . . . .	Number	 00000002h   
LEFT_CTRL_PRESSED  . . . . . . .	Number	 00000008h   
MB_ABORTRETRYIGNORE  . . . . . .	Number	 00000002h   
MB_APPLMODAL . . . . . . . . . .	Number	 00000000h   
MB_CANCELTRYCONTINUE . . . . . .	Number	 00000006h   
MB_DEFBUTTON1  . . . . . . . . .	Number	 00000000h   
MB_DEFBUTTON2  . . . . . . . . .	Number	 00000100h   
MB_DEFBUTTON3  . . . . . . . . .	Number	 00000200h   
MB_DEFBUTTON4  . . . . . . . . .	Number	 00000300h   
MB_HELP  . . . . . . . . . . . .	Number	 00004000h   
MB_ICONASTERISK  . . . . . . . .	Number	 00000040h   
MB_ICONERROR . . . . . . . . . .	Number	 00000010h   
MB_ICONEXCLAMATION . . . . . . .	Number	 00000030h   
MB_ICONHAND  . . . . . . . . . .	Number	 00000010h   
MB_ICONINFORMATION . . . . . . .	Number	 00000040h   
MB_ICONQUESTION  . . . . . . . .	Number	 00000020h   
MB_ICONSTOP  . . . . . . . . . .	Number	 00000010h   
MB_ICONWARNING . . . . . . . . .	Number	 00000030h   
MB_OKCANCEL  . . . . . . . . . .	Number	 00000001h   
MB_OK  . . . . . . . . . . . . .	Number	 00000000h   
MB_RETRYCANCEL . . . . . . . . .	Number	 00000005h   
MB_SYSTEMMODAL . . . . . . . . .	Number	 00001000h   
MB_TASKMODAL . . . . . . . . . .	Number	 00002000h   
MB_USERICON  . . . . . . . . . .	Number	 00000080h   
MB_YESNOCANCEL . . . . . . . . .	Number	 00000003h   
MB_YESNO . . . . . . . . . . . .	Number	 00000004h   
MENU_EVENT . . . . . . . . . . .	Number	 00000008h   
MOUSE_EVENT  . . . . . . . . . .	Number	 00000002h   
MessageBox . . . . . . . . . . .	Text   	 MessageBoxA
NULL . . . . . . . . . . . . . .	Number	 00000000h   
NUMLOCK_ON . . . . . . . . . . .	Number	 00000020h   
N  . . . . . . . . . . . . . . .	Number	 00000007h   
OPEN_ALWAYS  . . . . . . . . . .	Number	 00000004h   
OPEN_EXISTING  . . . . . . . . .	Number	 00000003h   
Output . . . . . . . . . . . . .	Byte	 00000022 _DATA	
PeekConsoleInput . . . . . . . .	Text   	 PeekConsoleInputA
RIGHT_ALT_PRESSED  . . . . . . .	Number	 00000001h   
RIGHT_CTRL_PRESSED . . . . . . .	Number	 00000004h   
ReadConsoleInput . . . . . . . .	Text   	 ReadConsoleInputA
ReadConsole  . . . . . . . . . .	Text   	 ReadConsoleA
SCROLLLOCK_ON  . . . . . . . . .	Number	 00000040h   
SHIFT_MASK . . . . . . . . . . .	Number	 00000010h   
SHIFT_PRESSED  . . . . . . . . .	Number	 00000010h   
STD_ERROR_HANDLE . . . . . . . .	Number	 -0000000Ch   
STD_INPUT_HANDLE . . . . . . . .	Number	 -0000000Ah   
STD_OUTPUT_HANDLE  . . . . . . .	Number	 -0000000Bh   
SetConsoleTitle  . . . . . . . .	Text   	 SetConsoleTitleA
TAB  . . . . . . . . . . . . . .	Number	 00000009h   
TRUE . . . . . . . . . . . . . .	Number	 00000001h   
TRUNCATE_EXISTING  . . . . . . .	Number	 00000005h   
VK_11  . . . . . . . . . . . . .	Number	 000000BDh   
VK_12  . . . . . . . . . . . . .	Number	 000000BBh   
VK_ADD . . . . . . . . . . . . .	Number	 0000006Bh   
VK_BACK  . . . . . . . . . . . .	Number	 00000008h   
VK_CANCEL  . . . . . . . . . . .	Number	 00000003h   
VK_CAPITAL . . . . . . . . . . .	Number	 00000014h   
VK_CLEAR . . . . . . . . . . . .	Number	 0000000Ch   
VK_CONTROL . . . . . . . . . . .	Number	 00000011h   
VK_DECIMAL . . . . . . . . . . .	Number	 0000006Eh   
VK_DELETE  . . . . . . . . . . .	Number	 0000002Eh   
VK_DIVIDE  . . . . . . . . . . .	Number	 0000006Fh   
VK_DOWN  . . . . . . . . . . . .	Number	 00000028h   
VK_END . . . . . . . . . . . . .	Number	 00000023h   
VK_ESCAPE  . . . . . . . . . . .	Number	 0000001Bh   
VK_EXECUTE . . . . . . . . . . .	Number	 0000002Bh   
VK_F10 . . . . . . . . . . . . .	Number	 00000079h   
VK_F11 . . . . . . . . . . . . .	Number	 0000007Ah   
VK_F12 . . . . . . . . . . . . .	Number	 0000007Bh   
VK_F13 . . . . . . . . . . . . .	Number	 0000007Ch   
VK_F14 . . . . . . . . . . . . .	Number	 0000007Dh   
VK_F15 . . . . . . . . . . . . .	Number	 0000007Eh   
VK_F16 . . . . . . . . . . . . .	Number	 0000007Fh   
VK_F17 . . . . . . . . . . . . .	Number	 00000080h   
VK_F18 . . . . . . . . . . . . .	Number	 00000081h   
VK_F19 . . . . . . . . . . . . .	Number	 00000082h   
VK_F1  . . . . . . . . . . . . .	Number	 00000070h   
VK_F20 . . . . . . . . . . . . .	Number	 00000083h   
VK_F21 . . . . . . . . . . . . .	Number	 00000084h   
VK_F22 . . . . . . . . . . . . .	Number	 00000085h   
VK_F23 . . . . . . . . . . . . .	Number	 00000086h   
VK_F24 . . . . . . . . . . . . .	Number	 00000087h   
VK_F2  . . . . . . . . . . . . .	Number	 00000071h   
VK_F3  . . . . . . . . . . . . .	Number	 00000072h   
VK_F4  . . . . . . . . . . . . .	Number	 00000073h   
VK_F5  . . . . . . . . . . . . .	Number	 00000074h   
VK_F6  . . . . . . . . . . . . .	Number	 00000075h   
VK_F7  . . . . . . . . . . . . .	Number	 00000076h   
VK_F8  . . . . . . . . . . . . .	Number	 00000077h   
VK_F9  . . . . . . . . . . . . .	Number	 00000078h   
VK_HELP  . . . . . . . . . . . .	Number	 0000002Fh   
VK_HOME  . . . . . . . . . . . .	Number	 00000024h   
VK_INSERT  . . . . . . . . . . .	Number	 0000002Dh   
VK_LBUTTON . . . . . . . . . . .	Number	 00000001h   
VK_LCONTROL  . . . . . . . . . .	Number	 000000A2h   
VK_LEFT  . . . . . . . . . . . .	Number	 00000025h   
VK_LMENU . . . . . . . . . . . .	Number	 000000A4h   
VK_LSHIFT  . . . . . . . . . . .	Number	 000000A0h   
VK_MENU  . . . . . . . . . . . .	Number	 00000012h   
VK_MULTIPLY  . . . . . . . . . .	Number	 0000006Ah   
VK_NEXT  . . . . . . . . . . . .	Number	 00000022h   
VK_NUMLOCK . . . . . . . . . . .	Number	 00000090h   
VK_NUMPAD0 . . . . . . . . . . .	Number	 00000060h   
VK_NUMPAD1 . . . . . . . . . . .	Number	 00000061h   
VK_NUMPAD2 . . . . . . . . . . .	Number	 00000062h   
VK_NUMPAD3 . . . . . . . . . . .	Number	 00000063h   
VK_NUMPAD4 . . . . . . . . . . .	Number	 00000064h   
VK_NUMPAD5 . . . . . . . . . . .	Number	 00000065h   
VK_NUMPAD6 . . . . . . . . . . .	Number	 00000066h   
VK_NUMPAD7 . . . . . . . . . . .	Number	 00000067h   
VK_NUMPAD8 . . . . . . . . . . .	Number	 00000068h   
VK_NUMPAD9 . . . . . . . . . . .	Number	 00000069h   
VK_PAUSE . . . . . . . . . . . .	Number	 00000013h   
VK_PRINT . . . . . . . . . . . .	Number	 0000002Ah   
VK_PRIOR . . . . . . . . . . . .	Number	 00000021h   
VK_RBUTTON . . . . . . . . . . .	Number	 00000002h   
VK_RCONTROL  . . . . . . . . . .	Number	 000000A3h   
VK_RETURN  . . . . . . . . . . .	Number	 0000000Dh   
VK_RIGHT . . . . . . . . . . . .	Number	 00000027h   
VK_RMENU . . . . . . . . . . . .	Number	 000000A5h   
VK_RSHIFT  . . . . . . . . . . .	Number	 000000A1h   
VK_SCROLL  . . . . . . . . . . .	Number	 00000091h   
VK_SEPARATER . . . . . . . . . .	Number	 0000006Ch   
VK_SHIFT . . . . . . . . . . . .	Number	 00000010h   
VK_SNAPSHOT  . . . . . . . . . .	Number	 0000002Ch   
VK_SPACE . . . . . . . . . . . .	Number	 00000020h   
VK_SUBTRACT  . . . . . . . . . .	Number	 0000006Dh   
VK_TAB . . . . . . . . . . . . .	Number	 00000009h   
VK_UP  . . . . . . . . . . . . .	Number	 00000026h   
WINDOW_BUFFER_SIZE_EVENT . . . .	Number	 00000004h   
WriteConsoleOutputCharacter  . .	Text   	 WriteConsoleOutputCharacterA
WriteConsole . . . . . . . . . .	Text   	 WriteConsoleA
black  . . . . . . . . . . . . .	Number	 00000000h   
blue . . . . . . . . . . . . . .	Number	 00000001h   
brown  . . . . . . . . . . . . .	Number	 00000006h   
cyan . . . . . . . . . . . . . .	Number	 00000003h   
exit . . . . . . . . . . . . . .	Text   	 INVOKE ExitProcess,0
falseOutput  . . . . . . . . . .	Byte	 0000002B _DATA	
gray . . . . . . . . . . . . . .	Number	 00000008h   
green  . . . . . . . . . . . . .	Number	 00000002h   
lightBlue  . . . . . . . . . . .	Number	 00000009h   
lightCyan  . . . . . . . . . . .	Number	 0000000Bh   
lightGray  . . . . . . . . . . .	Number	 00000007h   
lightGreen . . . . . . . . . . .	Number	 0000000Ah   
lightMagenta . . . . . . . . . .	Number	 0000000Dh   
lightRed . . . . . . . . . . . .	Number	 0000000Ch   
magenta  . . . . . . . . . . . .	Number	 00000005h   
modeluTemp . . . . . . . . . . .	Number	 -00000004h   
num  . . . . . . . . . . . . . .	Byte	 00000000 _DATA	
red  . . . . . . . . . . . . . .	Number	 00000004h   
res  . . . . . . . . . . . . . .	Byte	 00000007 _DATA	
sum1 . . . . . . . . . . . . . .	Number	 -00000007h   
temp1  . . . . . . . . . . . . .	Number	 -0000000Eh   
tempAstring  . . . . . . . . . .	Number	 -0000000Eh   
tempBstring  . . . . . . . . . .	Number	 -0000001Ch   
tempCstring  . . . . . . . . . .	Number	 -0000002Ah   
white  . . . . . . . . . . . . .	Number	 0000000Fh   
wsprintf . . . . . . . . . . . .	Text   	 wsprintfA
yellow . . . . . . . . . . . . .	Number	 0000000Eh   

	   0 Warnings
	   0 Errors
